---
title: "Forecast Similarity Using Cramer Distance Approximation"
author: "Johannes Bracher, Evan Ray, Nick Reich, Nutcha Wattanachit"
date: "05/28/2021"
header-includes:
   - \usepackage{amsmath}
   - \usepackage{tabularx}
   - \usepackage{hyperref}
   - \usepackage{multicol}
   - \usepackage{longtable}
   - \usepackage{array}
   - \usepackage{multirow}
   - \usepackage{wrapfig}
   - \usepackage{float}
   - \usepackage{colortbl}
   - \usepackage{pdflscape}
   - \usepackage{tabu}
   - \usepackage{threeparttable}
   - \usepackage{threeparttablex}
   - \usepackage{makecell}
   - \usepackage{xcolor}
output:
  pdf_document:
        keep_tex: true
        latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(ExtDist)
```

## Cramer Distance

Consider two predictive distributions $F$ and $G$. Their *Cramer distance* or *integrated quadratic distance*  is defined as

$$
\text{CD}(F, G) = \int_{-\infty}^\infty(F(x) - G(x))^2 dx
$$
where $F(x)$ and $G(x)$ denote the cumulative distribution functions. The Cramer distance is the divergence associated with the continuous ranked probability score (Thorarinsdottir 2013, Gneiting and Raftery 2007).

\begin{equation}
\text{CD}(F, G) = \mathbb{E}_{F, G}|x - y| - 0.5 \left[\mathbb{E}_F|x - x'| + \mathbb{E}_G|y - y'| \right], \label{eq:formulation_expectations}
\end{equation}
where $x, x'$ are independent random variables following $F$ and $y, y'$ are independent random variables following $G$. This formulation illustrates that the Cramer distance depends on the shift between $F$ and $G$ (first term) and the variability of both $F$ and $G$ (of which the two last expectations in above equation are a measure).

## Cramer Distance Approximation for Equally-Spaced Intervals

Now assume that for each of the distributions $F$ and $G$ we only know $K$ quantiles at equally spaced levels $1/(K + 1), 2/(K + 1), \dots, K/(K + 1)$. Denote these quantiles by $q^F_1, \dots, q^F_K$ and $q^G_1, \dots, q^G_K$, respectively. It is well known that the CRPS can be approximated by an average of linear quantile scores (Laio and Tamea 2007, Gneiting and Raftery 2007):
\begin{equation}
\text{CRPS}(F, y) \approx \frac{1}{K} \times \sum_{k = 1}^K 2\{\mathbf{1}(y \leq q^F_k)\} \times (q^F_k - y).\label{eq:linear_quantile_scores}
\end{equation}
This approximation is equivalent to the weighted interval score (WIS) which is in use for evaluation of quantile forecasts at the Forecast Hub, see Section 2.2 of Bracher et al (2021). This approximation can be generalized to the Cramer distance as
\begin{equation}
\text{CD}(F, G) \approx \frac{1}{K(K + 1)} \times \sum_{i = 1}^{2K - 1} b_i(b_i + 1)(q_{i + 1} - q_i),\label{eq:approx1}
\end{equation}
where we use the following notation:

* $\mathbf{q}$ is a vector of length $2K$. It is obtained by pooling the $q^F_k, q^G_k, k = 1, \dots, K$ and ordering them in increasing order (ties can be ordered in an arbitrary manner).
* $\mathbf{a}$ is a vector of length $2K$ containing the value $1$ wherever $\mathbf{q}$ contains a quantile of $F$ and $-1$ wherever it contains a value of $G$.
* $\mathbf{b}$ is a vector of length $2K$ containing the absolute cumulative sums of $\mathbf{a}$, i.e. $b_i = \left|\sum_{j = 1}^i a_j\right|$.

For small $K$ it seems that the slightly different approximation
\begin{equation}
\text{CD}(F, G) \approx \frac{1}{(K + 1)^2} \times \sum_{i = 1}^{2K - 1} b_i^2(q_{i + 1} - q_i),\label{eq:approx2}
\end{equation}
actually works better. This just corresponds to the integrated squared difference between two step functions $F^*$ and $G^*$ with $F^*(x) = 0$ for $x < q^F_1$, $F^*(x) = k/(K + 1)$ for $q^F_k \leq x < q^F_k$, $F^*(x) = K/(K + 1)$ for $x \geq x^F_K$ and $G^*$ defined accordingly. We illustrate this in the figure below, with light blue areas representing the CD and approximated CD.

## Cramer Distance Approximation for Unequally-Spaced Intervals 

Suppose we have quantiles $q_{1}^F,...,q_{K}^F$ and $q_{1}^G,...,q_{K}^G$ at $K$ probability levels $\tau_1,...,\tau_K$ from two distributions $F$ and $G$. Define the combined vector of quantiles $q_1, . . . , q_{2K}$ by combining the vectors $q_{1}^F,...,q_{K}^F$ and $q_{1}^G,...,q_{K}^G$ and sorting them in an ascending order. Essentially, we can approximate the Cramer distance by eliminating the tails of the integral to the left of $q_1$ and the right of $q_{2K}$, and approximating the center via a Riemann sum:


\begin{align}
\text{CD}(F,G) &=\int^\infty_{-\infty}{F(x)−G(x)}^2dx\\
&\approx \int^{q_{2K}}_{q_1}{F(x)−G(x)}^2dx\\
&=\sum^{2K-1}_{j=1}\int^{q_{j+1}}_{q_j}{F(x)−G(x)}^2dx
\end{align}

There are a variety of options that can be used for each term in this sum, for instance:

### Left-sided Riemann sum approximation

\begin{align}
\text{CD}(F,G) &\approx\sum^{2K-1}_{j=1}\int^{q_{j+1}}_{q_j}{F(x)−G(x)}^2\\
&\approx\sum^{2K-1}_{j=1}\{\hat{F}(q_j)-\hat{G}(q_j)\}^2(q_{j+1}-q_{j})\\
\end{align}


Since $q_j\in \{q_1, ..., q_{2K}\}$ belongs to either $q_{1}^F,...,q_{K}^F$ or $q_{1}^G,...,q_{K}^G$, we can rewrite the above approximation using $\tau_1,...,\tau_K$ as follows


\begin{align}
\text{CD}(F,G) 
&\approx\sum^{2K-1}_{j=1}\{\hat{F}(q_j)-\hat{G}(q_j)\}^2(q_{j+1}-q_{j})\\
&=\sum^{2K-1}_{j=1}\{\tau^F_j-\tau^G_j\}^2(q_{j+1}-q_{j})
\end{align}


where $\tau^F_j \in \boldsymbol{\tau_F}$ and $\tau^G_j \in \boldsymbol{\tau_G}$. $\boldsymbol{\tau_F}$ and $\boldsymbol{\tau_G}$ are vectors of length $2K-1$ with elements 

$$
\tau^F_j=
\begin{cases}
I(q_1=q_1^F)\times \tau_{q_1}^F\hspace{7cm}\text{for }j=1\\
I(q_j\in \{q_1^F, ..., q_{K}^F\})\times \tau_{q_j}^F+I(q_j\in \{q_1^G, ..., q_{K}^G\})\times \tau_{j-1}^F\hspace{0.3cm}\text{for }j>1\\
\end{cases}
$$

where $\tau_{q_j}^F$ is the probability level corresponding to $q_j$ given $q_j$ in the pooled quantiles comes from $F$, and $\tau_{j-1}^F$ is the $(j-1)^{th}$ probability level in $\boldsymbol{\tau_F}$.

$$
\tau^G_j=
\begin{cases}
I(q_1=q_1^G)\times \tau_{q_1}^G\hspace{7cm}\text{for }j=1\\
I(q_j\in \{q_1^G, ..., q_{K}^G\})\times \tau_{q_j}^G+I(q_j\in \{q_1^F,...,q_{K}^F\})\times \tau_{j-1}^G\hspace{0.3cm}\text{for }j>1\\
\end{cases}
$$

where $\tau_{q_j}^G$ is the probability level corresponding to $q_j$ given $q_j$ in the pooled quantiles comes from $G$, and $\tau_{j-1}^G$ is the $(j-1)^{th}$ probability level in $\boldsymbol{\tau_G}$.

### Trapezoidal rule

\begin{align}
\text{CD}(F,G) &\approx\sum^{2K-1}_{j=1}\int^{q_{j+1}}_{q_j}{F(x)−G(x)}^2\\
&\approx\sum^{2K-1}_{j=1}\frac{\{\hat{F}(q_j)-\hat{G}(q_j)\}^2+\{\hat{F}(q_{j+1})-\hat{G}(q_{j+1})\}^2}{2}(q_{j+1}-q_{j})\\
\end{align}


Similarly, we can rewrite the above approximation using $\tau_1,...,\tau_K$ as defined in the left-sided Riemann sum approximation as follows

\begin{align}
\text{CD}(F,G) 
&\approx\sum^{2K-1}_{j=1}\frac{\{\hat{F}(q_j)-\hat{G}(q_j)\}^2+\{\hat{F}(q_{j+1})-\hat{G}(q_{j+1})\}^2}{2}(q_{j+1}-q_{j})\\
&=
\sum^{2K-1}_{j=1}\frac{\{\tau^F_j-\tau^G_j\}^2+\{\tau^F_{j+1}-\tau^G_{j+1}\}^2}{2}(q_{j+1}-q_{j}).
\end{align}


## Cramer Distance Approximation for Unequally-Spaced Intervals and Different Probability Levels

We (probably) can further modify the formula of the Cramer distance approximation for unequally-spaced intervals to accommodate different probability levels from $F$ and $G$. Suppose we have quantiles $q_{1}^F,...,q_{N}^F$ at $K$ probability levels $\tau_1^F,...,\tau_N^F$ from the distribution $F$, and $q_{1}^G,...,q_{M}^G$ at $M$ probability levels $\tau_1^G,...,\tau_M^G$ from the distribution $G$. Define the combined vector of quantiles $q_1, . . . , q_{N+M}$ by combining the vectors $q_{1}^F,...,q_{N}^F$ and $q_{1}^G,...,q_{M}^G$ and again sorting them in an ascending order. Using the same definitions as previously defined, we can approximate the Cramer distance via a Riemann sum as follows:

### Left-sided Riemann sum approximation


\begin{align}
\text{CD}(F,G) &\approx\sum^{N+M-1}_{j=1}\int^{q_{j+1}}_{q_j}{F(x)−G(x)}^2\\
&\approx\sum^{N+M-1}_{j=1}\{\hat{F}(q_j)-\hat{G}(q_j)\}^2(q_{j+1}-q_{j}),\\
\end{align}

which we can rewrite using $\tau_1^F,...,\tau_N^F$ and $\tau_1^G,...,\tau_M^G$ as follows


\begin{align}
\text{CD}(F,G) 
&\approx\sum^{N+M-1}_{j=1}\{\hat{F}(q_j)-\hat{G}(q_j)\}^2(q_{j+1}-q_{j})\\
&=\sum^{N+M-1}_{j=1}\{\tau^F_j-\tau^G_j\}^2(q_{j+1}-q_{j})
\end{align}


where $\tau^F_j \in \boldsymbol{\tau_F}$ and $\tau^G_j \in \boldsymbol{\tau_G}$. $\boldsymbol{\tau_F}$ and $\boldsymbol{\tau_G}$ are vectors of length $N+M-1$ with elements 

$$
\tau^F_j=
\begin{cases}
\tau_{q_j}^F\hspace{2cm}\text{if }q_j\in \{q_1^F, ..., q_{N}^F\}\\
\tau_{q_{j-1}}^F\hspace{1.8cm}\text{if }q_j\notin \{q_1^F, ..., q_{N}^F\}\\
\end{cases}
$$

where $\tau_{q_j}^F$ is the probability level corresponding to $q_j$ given $q_j$ in the pooled quantiles comes from $F$.

$$
\tau^G_j=
\begin{cases}
\tau_{q_j}^G\hspace{2cm}\text{if }q_j\in \{q_1^G, ..., q_{M}^G\}\\
\tau_{q_{j-1}}^G\hspace{1.8cm}\text{if }q_j\notin \{q_1^G, ..., q_{M}^G\}\\
\end{cases}
$$

where $\tau_{q_j}^G$ is the probability level corresponding to $q_j$ given $q_j$ in the pooled quantiles comes from $G$.

### Trapezoidal rule


\begin{align}
\text{CD}(F,G) &\approx\sum^{2K-1}_{j=1}\int^{q_{j+1}}_{q_j}{F(x)−G(x)}^2\\
&\approx\sum^{N+M-1}_{j=1}\frac{\{\hat{F}(q_j)-\hat{G}(q_j)\}^2+\{\hat{F}(q_{j+1})-\hat{G}(q_{j+1})\}^2}{2}(q_{j+1}-q_{j}),\\
\end{align}

which we can rewrite as follows

\begin{align}
\text{CD}(F,G) 
&\approx\sum^{N+M-1}_{j=1}\frac{\{\hat{F}(q_j)-\hat{G}(q_j)\}^2+\{\hat{F}(q_{j+1})-\hat{G}(q_{j+1})\}^2}{2}(q_{j+1}-q_{j})\\
&=
\sum^{N+M-1}_{j=1}\frac{\{\tau^F_j-\tau^G_j\}^2+\{\tau^F_{j+1}-\tau^G_{j+1}\}^2}{2}(q_{j+1}-q_{j}).
\end{align}

<!-- ## Relationship Between the CD Approximations for Equally-Spaced Intervals and Unequally-Spaced Intervals -->


```{r}
# q_F: vector containing the (1:K)/(K + 1) quantiles of F
# q_G: vector containing the (1:K)/(K + 1) quantiles of G
approx_cd1 <- function(q_F, q_G){

  # compute quantile levels from length of provided quantile vectors:
  K <- length(q_F)
  if(length(q_G) != K) stop("q_F and q_G need to be of the same length")
  p <- (1:K)/(K + 1) # function assumes that the quantile levels are equally spaced

  # pool quantiles:
  q0 <- c(q_F, q_G)
  # vector of grouping variables, with 1 for values belonging to F, -1 for values
  # belonging to G
  a0 <- c(rep(1, length(q_F)), rep(-1, length(q_G)))

  # re-order both vectors:
  q <- q0[order(q0)]
  a <- a0[order(q0)]
  # and compute "how many quantiles ahead" F or G is at a given segment:
  b <- abs(cumsum(a))

  # compute the lengths of segments defined by sorted quantiles:
  diffs_q <- c(diff(q), 0) # zero necessary for indexing below, but we could put
  # anything (gets multiplied w zero)

  # and approximate CD
  cvm <- sum(diffs_q*b*(b + 1))/(K + 1)/(K)

  # return(mean(cvm))
  return(cvm)
}

# q_F: vector containing the (1:K)/(K + 1) quantiles of F
# q_G: vector containing the (1:K)/(K + 1) quantiles of G
approx_cd2 <- function(q_F, q_G){

  # compute quantile levels from length of provided quantile vectors:
  K <- length(q_F)
  if(length(q_G) != K) stop("q_F and q_G need to be of the same length")
  p <- (1:K)/(K + 1) # function assumes that the quantile levels are equally spaced

  # pool quantiles:
  q0 <- c(q_F, q_G)
  # vector of grouping variables, with 1 for values belonging to F, -1 for values
  # belonging to G
  a0 <- c(rep(1, length(q_F)), rep(-1, length(q_G)))

  # re-order both vectors:
  q <- q0[order(q0)]
  a <- a0[order(q0)]
  # and compute "how many quantiles ahead" F or G is at a given segment:
  b <- abs(cumsum(a))

  # compute the lengths of segments defined by sorted quantiles:
  diffs_q <- c(diff(q), 0) # zero necessary for indexing below, but we could put
  # anything (gets multiplied w zero)

  # and approximate CD
  cvm <- sum(diffs_q*b^2/K^2)

  return(mean(cvm))
}
approx_cd_uneq <- function(q_F, tau_F, q_G, tau_G, approx_rule="left-sided"){
# check rules
    if (!(approx_rule %in% c("left-sided", "trapezoid"))) {
      stop("invalid approximation rule")
    }
    # check quantile order
    q_F_ordered <- sort(q_F)
    q_G_ordered <- sort(q_G)
    if (sum(q_F != q_F_ordered)>0) {
      warning("q_F has been re-ordered to correspond to increasing probability levels")
    }
    if (sum(q_G != q_G_ordered)>0) {
      warning("q_G has been re-ordered to correspond to increasing probability levels")
    }
    # check probability level order
    tau_F_ordered <- sort(tau_F)
    tau_G_ordered <- sort(tau_G)
    if (sum(tau_F != tau_F_ordered)>0) {
      warning("tau_F has been sorted to in an increasing order")
    }
    if (sum(tau_G != tau_G_ordered)>0) {
      warning("tau_G has been sorted to in an increasing order")
    }
    # check conditions
    if (length(q_F_ordered) != length(tau_F_ordered)) {
      stop("The lengths of q_F_ordered and tau_F_ordered need to be equal")
    }
    if (length(q_G_ordered) != length(tau_G_ordered)) {
      stop("The lengths of q_G_ordered and tau_G_ordered need to be equal")
    }
    if (sum(tau_F_ordered<=1)!=length(tau_F_ordered)|sum(tau_F_ordered>=0)!=length(tau_F_ordered)) {
      stop("The values of tau_F_ordered have to be between 0 and 1")
    }
    if (sum(tau_G_ordered<=1)!=length(tau_G_ordered)|sum(tau_G_ordered>=0)!=length(tau_G_ordered)) {
      stop("The values of tau_G_ordered have to be between 0 and 1")
    }
    if (length(q_F_ordered) != length(q_G_ordered)) {
      message("The lengths of q_F_ordered and q_G_ordered are not equal")
    }
    N <- length(q_F_ordered)
    M <- length(q_G_ordered)
    # pool quantiles:
    q0 <- c(q_F_ordered, q_G_ordered)
    # indicator whether the entry is from F or G
    q <- q0[order(q0)]
    tf <- unlist(sapply(q, function(x) ifelse(x %in% q_F_ordered,tau_F_ordered[which(x == q_F_ordered)],0)))
    tg <- unlist(sapply(q, function(x) ifelse(x %in% q_G_ordered,tau_G_ordered[which(x == q_G_ordered)],0)))
    diffs_q <- diff(q)
    # probability level vectors
    tau_F_v <- cummax(tf)
    tau_G_v <- cummax(tg)
    if (approx_rule == "left-sided") {
      cvm <-
        sum(((tau_F_v[1:(N + M) - 1] - tau_G_v[1:(N + M) - 1]) ^ 2) * diffs_q)
    } else if (approx_rule == "trapezoid") {
      cvm <-
        sum((((tau_F_v[1:(N + M) - 1] - tau_G_v[1:(N + M) - 1]) ^ 2 + (tau_F_v[2:(N +
                                                                                    M)] - tau_G_v[2:(N + M)]) ^ 2
        ) / 2) * diffs_q)
    }
    return(cvm)
}
```

# Examples

## Equally-spaced intervals

```{r, fig.height=5, fig.width=8}
grid_x <- seq(from = 3, to = 15, by = 0.1)

mu_F <- 9
sigma_F <- 1.8
p_F <- pnorm(grid_x, mu_F, sigma_F)

mu_G <- 10
sigma_G <- 1
p_G <- pnorm(grid_x, mu_G, sigma_G)

y <- mu_G
p_y <- as.numeric(grid_x > y)

par(mfrow = c(2, 2))

plot(grid_x, p_F, type = "l", xlab = "x", ylab = "CDF", col = "red")
lines(grid_x, p_G, col = "blue")
legend("topleft", c("F", "G"), col = c("red", "blue"), lty = 1)

plot(grid_x, (p_F - p_G)^2, type = "l", xlab = "x", ylab = "(F(x) - G(x))^2", ylim = c(0, 0.3))
polygon(grid_x, (p_F - p_G)^2, col = "lightblue")
legend("topleft", "CD", col = "lightblue", pch = 15)

detail_stepfun_cdf <- function(x, p, from, to, by = 0.1){
  x_detailed <- seq(from = from, to = to, by = by)
  p_detailed <- 0*x_detailed
  for(i in seq_along(x)){
    p_detailed[x_detailed >= x[i]] <- p[i]
  }
  return(list(x = x_detailed, p = p_detailed))
}

p_10 <- 1:9/10 # quantile levels
q_F_10 <- qnorm(p_10, mu_F, sigma_F) # quantiles of F
q_G_10 <- qnorm(p_10, mu_G, sigma_G) # quantiles of G

q_F_10_detailed <- detail_stepfun_cdf(q_F_10, p_10, from = 3, to = 15)
q_G_10_detailed <- detail_stepfun_cdf(q_G_10, p_10, from = 3, to = 15)
p_10_detailed <- q_F_10_detailed$x

plot(q_F_10_detailed$x, q_F_10_detailed$p, type = "s", xlab = "x", ylab = "CDF", col = "red")
lines(q_F_10_detailed$x, q_G_10_detailed$p, type = "s", col = "blue")

plot(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, type = "s", xlab = "x",
     ylab = "(F*(x) - G*(x))^2", ylim = c(0, 0.3))
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, col = "lightblue")
legend("topleft", "approx. CD", col = "lightblue", pch = 15)

```

In this example, six different approximations are applied to the distributions $F~N(9, 1.8)$ and $G~N(10, 1)$ in the figures above.

```{r}
# define distributions:
mu_F <- 9
sigma_F <- 1.8

mu_G <- 10
sigma_G <- 1
```

* Using direct numerical integration based on a fine grid of values for $x$:

```{r}
# simple numerical integration using grid:
(cd_grid <- 0.1*sum((p_F - p_G)^2))
```

* Using sampling and the alternative expression \eqref{eq:formulation_expectations} of the CD from above:

```{r}
n <- 100000
set.seed(123)
x <- rnorm(n, mu_F, sigma_F)
x_dash <- rnorm(n, mu_F, sigma_F)

y <- rnorm(n, mu_G, sigma_G)
y_dash <- rnorm(n, mu_G, sigma_G)

(cd_sample <- (mean(abs(x - y)) - 0.5*(mean(abs(x - x_dash)) + mean(abs(y - y_dash)))))
```

* Using the first quantile-based approximation \eqref{eq:approx2} and various values of $K$:

```{r}

# values of K to check:
values_K <- c(10, 20, 50, 100, 200, 500, 1000, 2000)

# vector to store results:
cd_approx1 <- numeric(length(values_K))

# apply approximation for each_
for(i in seq_along(values_K)){
  p_temp <- (1:(values_K[i]))/(values_K[i] + 1) # quantile levels
  q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
  q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
  cd_approx1[i] <- approx_cd1(q_F = q_F_temp, q_G = q_G_temp) # approximation
}

cd_approx1
```

* Using the second quantile-based approximation \eqref{eq:approx2} and various values of $K$:

```{r}
# vector to store results:
cd_approx2 <- numeric(length(values_K))

# apply approximation for each_
for(i in seq_along(values_K)){
  p_temp <- (1:(values_K[i] - 1))/values_K[i] # quantile levels
  q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
  q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
  cd_approx2[i] <- approx_cd2(q_F = q_F_temp, q_G = q_G_temp) # approximation
}

cd_approx2
```

* Using the left-sided Riemann sum approximation and various values of $K$:

```{r}
# vector to store results:
cd_approx3 <- numeric(length(values_K))

# apply approximation for each_
for(i in seq_along(values_K)){
  p_temp <- (1:(values_K[i] - 1))/values_K[i] # quantile levels
  q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
  q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
  cd_approx3[i] <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                                  q_G = q_G_temp, tau_G = p_temp,
                                  approx_rule="left-sided") # approximation
}

cd_approx3
```

* Using the trapezoidal Riemann sum approximation and various values of $K$:

```{r}
# vector to store results:
cd_approx4 <- numeric(length(values_K))

# apply approximation for each_
for(i in seq_along(values_K)){
  p_temp <- (1:(values_K[i] - 1))/values_K[i] # quantile levels
  q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
  q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
  cd_approx4[i] <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                                  q_G = q_G_temp, tau_G = p_temp,
                                  approx_rule="trapezoid") # approximation
}
cd_approx4
```

The below plot shows the results from the different computations.

```{r}
# plot:
plot(values_K, cd_approx1, ylim = c(0, 0.5), xlab = "K", ylab = "CD",
     pch = 1, type = "b", log = "x", col = "darkorange")
lines(values_K, cd_approx2, type = "b", col = "darkgreen")
lines(values_K, cd_approx3, type = "b", col = "blue")
lines(values_K, cd_approx4, type = "b", col = "brown")
abline(h = cd_grid, col = "black")
abline(h = cd_sample, col = "purple", lty = 2)
legend("topright",
       c("grid-based", "sample-based", "quantile approx. 1", "quantile approx. 2",
         "uneq quantile approx. 1", "uneq quantile approx. 2"),
       pch = c(NA, NA, 1, 1, 1, 1), lty = c(1, 2, NA, NA,NA, NA),
       col = c("black", "purple", "darkorange", "darkgreen","blue","brown"),
       cex=0.8)
```

In the case that $G$ is a point mass at $y=10$, approximation \eqref{eq:approx1} indeed coincides with \eqref{eq:linear_quantile_scores}.

```{r}
# define G_star
y <- 10
q_G_star <- rep(y, 9)

print(paste0("Quantile approx. 1: ", approx_cd1(q_F_10, q_G_star)))# approximation 1
print(paste0("Quantile approx. 2: ",approx_cd2(q_F_10, q_G_star))) # approximation 2
print(paste0("Uneq quantile approx. 1: ",approx_cd_uneq(q_F = q_F_10, tau_F = c(1:9/10),
               q_G = q_G_star, tau_G = c(1:9/10),
                                  approx_rule="left-sided")))# approximation 3
print(paste0("Uneq quantile approx. 2: ",approx_cd_uneq(q_F = q_F_10, tau_F = c(1:9/10),
               q_G = q_G_star, tau_G = c(1:9/10),
               approx_rule="trapezoid"))) # approximation 4
print(paste0("Quantile score WIS: ",mean(2*((y <= q_F_10) - p_10)*(q_F_10 - y)))) # WIS defined via quantile scores
```

The approximation \eqref{eq:approx1} is closer to the grid-based direct evaluation of the integral. Since the unequally-spaced approximations were not formulated from (equally-spaced) WIS, it may be expected.

```{r}
# grid-based approximation:
p_G_star <- as.numeric(grid_x >= y)
print(paste0("Grid-based approx.: ", 0.1*sum((p_F - p_G_star)^2)))
```

## Unequally-spaceed intervals

We apply the same six approximations as in the previous example to the two distributions $F\sim N(8,2)$ and $G \sim N(11,1)$ whose quantiles correspond to unequally-spaced probability levels. 

### 7 quantiles with unequally-spaced intervals

The probability levels corresponding to the given set of quantiles in this example is $0.025,0.1,0.25,0.5,0.75,0.9,0.975$, which is the same probability levels provided by the COVID-hub case forecasts.

```{r, echo=FALSE, fig.height=5, fig.width=8}
grid_x <- seq(from = 3, to = 16, by = 0.1)

mu_F <- 8
sigma_F <- 2
p_F <- pnorm(grid_x, mu_F, sigma_F)

mu_G <- 11
sigma_G <- 1
p_G <- pnorm(grid_x, mu_G, sigma_G)

y <- mu_G
p_y <- as.numeric(grid_x > y)

par(mfrow = c(2, 2))

plot(grid_x, p_F, type = "l", xlab = "x", ylab = "CDF", col = "red")
lines(grid_x, p_G, col = "blue")
legend("topleft", c("F", "G"), col = c("red", "blue"), lty = 1)

plot(grid_x, (p_F - p_G)^2, type = "l", xlab = "x", ylab = "(F(x) - G(x))^2", ylim = c(0, 0.7))
polygon(grid_x, (p_F - p_G)^2, col = "lightblue")
legend("topleft", "CD", col = "lightblue", pch = 15)

detail_stepfun_cdf <- function(x, p, from, to, by = 0.1){
  x_detailed <- seq(from = from, to = to, by = by)
  p_detailed <- 0*x_detailed
  for(i in seq_along(x)){
    p_detailed[x_detailed >= x[i]] <- p[i]
  }
  return(list(x = x_detailed, p = p_detailed))
}

p_10 <- c(0.025,0.1,0.25,0.5,0.75,0.9,0.975)
q_F_10 <- qnorm(p_10, mu_F, sigma_F) # quantiles of F
q_G_10 <- qnorm(p_10, mu_G, sigma_G) # quantiles of G

q_F_10_detailed <- detail_stepfun_cdf(q_F_10, p_10, from = 3, to = 16)
q_G_10_detailed <- detail_stepfun_cdf(q_G_10, p_10, from = 3, to = 16)
p_10_detailed <- q_F_10_detailed$x

plot(q_F_10_detailed$x, q_F_10_detailed$p, type = "s", xlab = "x", ylab = "CDF", col = "red")
lines(q_F_10_detailed$x, q_G_10_detailed$p, type = "s", col = "blue")

plot(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, type = "s", xlab = "x",
     ylab = "(F*(x) - G*(x))^2", ylim = c(0, 0.7))
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, col = "lightblue")
legend("topleft", "approx. CD", col = "lightblue", pch = 15)

```


* Using direct numerical integration based on a fine grid of values for $x$.

```{r}
# simple numerical integration using grid:
(cd_grid <- 0.1*sum((p_F - p_G)^2))
```

* Using sampling and the alternative expression \eqref{eq:formulation_expectations} of the CD from above:
```{r}
n <- 100000
set.seed(123)
x <- rnorm(n, mu_F, sigma_F)
x_dash <- rnorm(n, mu_F, sigma_F)

y <- rnorm(n, mu_G, sigma_G)
y_dash <- rnorm(n, mu_G, sigma_G)

(cd_sample <- (mean(abs(x - y)) - 0.5*(mean(abs(x - x_dash)) + mean(abs(y - y_dash)))))
```

* Using the first quantile-based approximation:

```{r}
k <- length(p_10)
# apply approximation for each_
p_temp <- (1:k)/(k + 1) # quantile levels
q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
cd_approx1 <- approx_cd1(q_F = q_F_temp, q_G = q_G_temp) # approximation


cd_approx1
```

* Using the second quantile-based approximation:

```{r}
cd_approx2 <- approx_cd2(q_F = q_F_temp, q_G = q_G_temp) # approximation

cd_approx2
```

* Using the left-sided Riemann sum-based approximation:

```{r}
# apply approximation for each_
cd_approx3 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="left-sided") # approximation
cd_approx3
```

* Using the trapezoidal Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx4 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="trapezoid") # approximation
cd_approx4
```

Out of all four quantile-based approximation, the trapezoidal Riemann sum-based approximation is closest to the grid-based integral evaluation.

### 23 quantiles with 2 unequally-spaced probability levels at the tails

Using the same $F$ and $G$, the probability levels corresponding to the given set of quantiles in this example is the same probability levels provided by the COVID-hub death forecasts. They are almost equally-spaced, except at the tails.

```{r, echo=FALSE, fig.height=5, fig.width=8}
grid_x <- seq(from = 3, to = 16, by = 0.1)

mu_F <- 8
sigma_F <- 2
p_F <- pnorm(grid_x, mu_F, sigma_F)

mu_G <- 11
sigma_G <- 1
p_G <- pnorm(grid_x, mu_G, sigma_G)

y <- mu_G
p_y <- as.numeric(grid_x > y)

par(mfrow = c(2, 2))

plot(grid_x, p_F, type = "l", xlab = "x", ylab = "CDF", col = "red")
lines(grid_x, p_G, col = "blue")
legend("topleft", c("F", "G"), col = c("red", "blue"), lty = 1)

plot(grid_x, (p_F - p_G)^2, type = "l", xlab = "x", ylab = "(F(x) - G(x))^2", ylim = c(0, 0.7))
polygon(grid_x, (p_F - p_G)^2, col = "lightblue")
legend("topleft", "CD", col = "lightblue", pch = 15)

detail_stepfun_cdf <- function(x, p, from, to, by = 0.1){
  x_detailed <- seq(from = from, to = to, by = by)
  p_detailed <- 0*x_detailed
  for(i in seq_along(x)){
    p_detailed[x_detailed >= x[i]] <- p[i]
  }
  return(list(x = x_detailed, p = p_detailed))
}

p_10 <- c(0.01,0.025,seq(0.05,0.95,0.05),0.975,0.99) # quantile levels
# for case
# p_10 <- c(0.025,0.1,0.25,0.5,0.75,0.9,0.975) 
q_F_10 <- qnorm(p_10, mu_F, sigma_F) # quantiles of F
q_G_10 <- qnorm(p_10, mu_G, sigma_G) # quantiles of G

q_F_10_detailed <- detail_stepfun_cdf(q_F_10, p_10, from = 3, to = 16)
q_G_10_detailed <- detail_stepfun_cdf(q_G_10, p_10, from = 3, to = 16)
p_10_detailed <- q_F_10_detailed$x

plot(q_F_10_detailed$x, q_F_10_detailed$p, type = "s", xlab = "x", ylab = "CDF", col = "red")
lines(q_F_10_detailed$x, q_G_10_detailed$p, type = "s", col = "blue")

plot(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, type = "s", xlab = "x",
     ylab = "(F*(x) - G*(x))^2", ylim = c(0, 0.7))
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, col = "lightblue")
legend("topleft", "approx. CD", col = "lightblue", pch = 15)

```

* Using the first quantile-based approximation:

```{r}
k <- length(p_10)
# apply approximation for each_
p_temp <- (1:k)/(k + 1) # quantile levels
q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
cd_approx1 <- approx_cd1(q_F = q_F_temp, q_G = q_G_temp) # approximation


cd_approx1
```

* Using the second quantile-based approximation:

```{r}
cd_approx2 <- approx_cd2(q_F = q_F_temp, q_G = q_G_temp) # approximation

cd_approx2
```

* Using the left-sided Riemann sum-based approximation:

```{r}
# apply approximation for each_
cd_approx3 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="left-sided") # approximation
cd_approx3
```

* Using the trapezoidal Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx4 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="trapezoid") # approximation
cd_approx4
```

Again, the trapezoidal Riemann sum-based approximation is closest to the grid-based integral evaluation of 1.493653.

### Examples of Disagreement Between Equally- and Unequally-spaced Interval Methods

#### Heavy tails

Suppose we have three cumulative distributions, $F\sim N(1,1)$, $G\sim N(2,1)$ and $H\sim T_1$, represented by 7 unequally-spaced quantiles. The probability levels corresponding to the given set of quantiles in this example is $0.025,0.1,0.25,0.5,0.75,0.9,0.975$.

```{r, echo=FALSE, fig.height=5, fig.width=8}
grid_x <- seq(from = -8, to = 10, by = 0.1)

mu_F <- 1
sigma_F <- 1
p_F <- pnorm(grid_x, mu_F, sigma_F)

mu_G <- 2
sigma_G <- 1
p_G <- pnorm(grid_x, mu_G, sigma_G)

# try laplace instead of t
deg <- 1
p_H <- pt(grid_x, deg, lower.tail = TRUE, log.p = FALSE)

par(mfrow = c(2, 2))

plot(grid_x, p_F, type = "l", xlab = "x", ylab = "CDF", col = "red")
lines(grid_x, p_G, col = "blue")
lines(grid_x, p_H, col = "green")
legend("topleft", c("F", "G", "H"), col = c("red", "blue","green"), lty = 1)

plot(grid_x, (p_F - p_G)^2, type = "l", xlab = "x", ylab = "Squared Distance", ylim = c(0, 0.5))
polygon(grid_x, (p_F - p_G)^2, col = "lightblue",)
lines(grid_x, (p_F - p_H)^2, col = "lightgreen")
polygon(grid_x, (p_F - p_H)^2, col = "lightgreen")
lines(grid_x, (p_H - p_G)^2, col = rgb(1, 1, 0,0.5))
polygon(grid_x, (p_H - p_G)^2, col = rgb(1, 1, 0,0.5))
legend("topleft", c("F vs G","F vs H","H vs G"), 
       col = c("lightblue","lightgreen",rgb(1, 1, 0,0.5)), pch = 15)

p_10 <- c(0.025,0.1,0.25,0.5,0.75,0.9,0.975)
q_F_10 <- qnorm(p_10, mu_F, sigma_F) # quantiles of F
q_G_10 <- qnorm(p_10, mu_G, sigma_G) # quantiles of G
q_H_10 <- qt(p_10, deg, lower.tail = TRUE, log.p = FALSE)# quantiles of H

q_F_10_detailed <- detail_stepfun_cdf(q_F_10, p_10, from = -8, to = 10)
q_G_10_detailed <- detail_stepfun_cdf(q_G_10, p_10, from = -8, to = 10)
q_H_10_detailed <- detail_stepfun_cdf(q_H_10, p_10, from = -8, to = 10)

p_10_detailed <- q_F_10_detailed$x

plot(q_F_10_detailed$x, q_F_10_detailed$p, type = "s", xlab = "x", ylab = "CDF", col = "red")
lines(q_F_10_detailed$x, q_G_10_detailed$p, type = "s", col = "blue")
lines(q_F_10_detailed$x, q_H_10_detailed$p, type = "s", col = "green")

plot(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, type = "s", xlab = "x",
     ylab = "Squared Distance", ylim = c(0, 0.5))
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, col = "lightblue")
lines(q_F_10_detailed$x, (q_F_10_detailed$p - q_H_10_detailed$p)^2, col = "lightgreen")
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_H_10_detailed$p)^2, col = "lightgreen")
lines(q_F_10_detailed$x, (q_H_10_detailed$p - q_G_10_detailed$p)^2, col = rgb(1, 1, 0,0.5))
polygon(q_F_10_detailed$x, (q_H_10_detailed$p - q_G_10_detailed$p)^2, col = rgb(1, 1, 0,0.5))
legend("topleft", c("F vs G","F vs H","H vs G"), 
       col = c("lightblue","lightgreen",rgb(1, 1, 0,0.5)), pch = 15)
```


* Using direct numerical integration based on a fine grid of values for $x$.

```{r}
# simple numerical integration using grid:
print(paste0("CD of F vs G: ",(cd_grid <- 0.1*sum((p_F - p_G)^2))))
print(paste0("CD of F vs H: ",(cd_grid <- 0.1*sum((p_F - p_H)^2))))
print(paste0("CD of H vs G: ",(cd_grid <- 0.1*sum((p_H - p_G)^2))))
```

* Using the first quantile-based approximation:

```{r}
k <- length(p_10)
# apply approximation for each_
p_temp <- (1:k)/(k + 1) # quantile levels
q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
q_H_temp <- qt(p_temp, deg, lower.tail = TRUE, log.p = FALSE)# quantiles of H
cd_approx11 <- approx_cd1(q_F = q_F_temp, q_G = q_G_temp) # approximation
cd_approx12 <- approx_cd1(q_F = q_F_temp, q_G = q_H_temp) # approximation
cd_approx13 <- approx_cd1(q_F = q_H_temp, q_G = q_G_temp) # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx11))
print(paste0("Approx. CD of F vs H: ",cd_approx12))
print(paste0(" Approx. CD of H vs G: ",cd_approx13))
```

* Using the second quantile-based approximation:

```{r}
cd_approx21 <- approx_cd2(q_F = q_F_temp, q_G = q_G_temp) # approximation
cd_approx22 <- approx_cd2(q_F = q_F_temp, q_G = q_H_temp) # approximation
cd_approx23 <- approx_cd2(q_F = q_H_temp, q_G = q_G_temp) # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx21))
print(paste0("Approx. CD of F vs H: ",cd_approx22))
print(paste0(" Approx. CD of H vs G: ",cd_approx23))
```

* Using the left-sided Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx31 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="left-sided") # approximation
cd_approx32 <- approx_cd_uneq(q_F = q_F_temp,tau_F = p_temp,
                          q_G = q_H_temp, tau_G = p_temp,
                          approx_rule="left-sided") # approximation
cd_approx33 <- approx_cd_uneq(q_F = q_H_temp,  tau_F = p_temp,
                          q_G = q_G_temp, tau_G = p_temp,
                          approx_rule="left-sided") # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx31))
print(paste0("Approx. CD of F vs H: ",cd_approx32))
print(paste0(" Approx. CD of H vs G: ",cd_approx33))
```

* Using the trapezoidal Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx41 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="trapezoid") # approximation
cd_approx42 <- approx_cd_uneq(q_F = q_F_temp,tau_F = p_temp,
                          q_G = q_H_temp, tau_G = p_temp,
                          approx_rule="trapezoid") # approximation
cd_approx43 <- approx_cd_uneq(q_F = q_H_temp,  tau_F = p_temp,
                          q_G = q_G_temp, tau_G = p_temp,
                          approx_rule="trapezoid") # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx41))
print(paste0("Approx. CD of F vs H: ",cd_approx42))
print(paste0(" Approx. CD of H vs G: ",cd_approx43))
```

#### Long tails

Suppose we have three cumulative distributions, $F\sim N(0,1)$, $G\sim N(1,1)$ and $H\sim \text{Laplace}(0,1)$, represented by 7 unequally-spaced quantiles. The probability levels corresponding to the given set of quantiles in this example is $0.025,0.1,0.25,0.5,0.75,0.9,0.975$.

```{r, echo=FALSE, fig.height=5, fig.width=8}
grid_x <- seq(from = -5, to = 5, by = 0.1)

mu_F <- 0
sigma_F <- 1
p_F <- pnorm(grid_x, mu_F, sigma_F)

mu_G <- 1
sigma_G <- 1
p_G <- pnorm(grid_x, mu_G, sigma_G)

# try laplace instead of t
mu_H <- 0
b <- 1
p_H <- ExtDist::pLaplace(grid_x, mu_H, b)

par(mfrow = c(2, 2))

plot(grid_x, p_F, type = "l", xlab = "x", ylab = "CDF", col = "red")
lines(grid_x, p_G, col = "blue")
lines(grid_x, p_H, col = "green")
legend("topleft", c("F", "G", "H"), col = c("red", "blue","green"), lty = 1)

plot(grid_x, (p_F - p_G)^2, type = "l", xlab = "x", ylab = "Squared Distance", ylim = c(0, 0.5))
polygon(grid_x, (p_F - p_G)^2, col = "lightblue",)
lines(grid_x, (p_F - p_H)^2, col = "lightgreen")
polygon(grid_x, (p_F - p_H)^2, col = "lightgreen")
lines(grid_x, (p_H - p_G)^2, col = rgb(1, 1, 0,0.5))
polygon(grid_x, (p_H - p_G)^2, col = rgb(1, 1, 0,0.5))
legend("topleft", c("F vs G","F vs H","H vs G"), 
       col = c("lightblue","lightgreen",rgb(1, 1, 0,0.5)), pch = 15)

p_10 <- c(0.025,0.1,0.25,0.5,0.75,0.9,0.975)
q_F_10 <- qnorm(p_10, mu_F, sigma_F) # quantiles of F
q_G_10 <- qnorm(p_10, mu_G, sigma_G) # quantiles of G
q_H_10 <- qt(p_10, deg, lower.tail = TRUE, log.p = FALSE)# quantiles of H

q_F_10_detailed <- detail_stepfun_cdf(q_F_10, p_10, from = -8, to = 10)
q_G_10_detailed <- detail_stepfun_cdf(q_G_10, p_10, from = -8, to = 10)
q_H_10_detailed <- detail_stepfun_cdf(q_H_10, p_10, from = -8, to = 10)

p_10_detailed <- q_F_10_detailed$x

plot(q_F_10_detailed$x, q_F_10_detailed$p, type = "s", xlab = "x", ylab = "CDF", col = "red")
lines(q_F_10_detailed$x, q_G_10_detailed$p, type = "s", col = "blue")
lines(q_F_10_detailed$x, q_H_10_detailed$p, type = "s", col = "green")

plot(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, type = "s", xlab = "x",
     ylab = "Squared Distance", ylim = c(0, 0.5))
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_G_10_detailed$p)^2, col = "lightblue")
lines(q_F_10_detailed$x, (q_F_10_detailed$p - q_H_10_detailed$p)^2, col = "lightgreen")
polygon(q_F_10_detailed$x, (q_F_10_detailed$p - q_H_10_detailed$p)^2, col = "lightgreen")
lines(q_F_10_detailed$x, (q_H_10_detailed$p - q_G_10_detailed$p)^2, col = rgb(1, 1, 0,0.5))
polygon(q_F_10_detailed$x, (q_H_10_detailed$p - q_G_10_detailed$p)^2, col = rgb(1, 1, 0,0.5))
legend("topleft", c("F vs G","F vs H","H vs G"), 
       col = c("lightblue","lightgreen",rgb(1, 1, 0,0.5)), pch = 15)
```


* Using direct numerical integration based on a fine grid of values for $x$.

```{r}
# simple numerical integration using grid:
print(paste0("CD of F vs G: ",(cd_grid <- 0.1*sum((p_F - p_G)^2))))
print(paste0("CD of F vs H: ",(cd_grid <- 0.1*sum((p_F - p_H)^2))))
print(paste0("CD of H vs G: ",(cd_grid <- 0.1*sum((p_H - p_G)^2))))
```

* Using the first quantile-based approximation:

```{r}
k <- length(p_10)
# apply approximation for each_
p_temp <- (1:k)/(k + 1) # quantile levels
q_F_temp <- qnorm(p_temp, mu_F, sigma_F) # quantiles of F
q_G_temp <- qnorm(p_temp, mu_G, sigma_G) # quantiles of G
q_H_temp <- qLaplace(p_temp, mu_H, b)# quantiles of H
cd_approx11 <- approx_cd1(q_F = q_F_temp, q_G = q_G_temp) # approximation
cd_approx12 <- approx_cd1(q_F = q_F_temp, q_G = q_H_temp) # approximation
cd_approx13 <- approx_cd1(q_F = q_H_temp, q_G = q_G_temp) # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx11))
print(paste0("Approx. CD of F vs H: ",cd_approx12))
print(paste0(" Approx. CD of H vs G: ",cd_approx13))
```

* Using the second quantile-based approximation:

```{r}
cd_approx21 <- approx_cd2(q_F = q_F_temp, q_G = q_G_temp) # approximation
cd_approx22 <- approx_cd2(q_F = q_F_temp, q_G = q_H_temp) # approximation
cd_approx23 <- approx_cd2(q_F = q_H_temp, q_G = q_G_temp) # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx21))
print(paste0("Approx. CD of F vs H: ",cd_approx22))
print(paste0(" Approx. CD of H vs G: ",cd_approx23))
```

* Using the left-sided Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx31 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="left-sided") # approximation
cd_approx32 <- approx_cd_uneq(q_F = q_F_temp,tau_F = p_temp,
                          q_G = q_H_temp, tau_G = p_temp,
                          approx_rule="left-sided") # approximation
cd_approx33 <- approx_cd_uneq(q_F = q_H_temp,  tau_F = p_temp,
                          q_G = q_G_temp, tau_G = p_temp,
                          approx_rule="left-sided") # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx31))
print(paste0("Approx. CD of F vs H: ",cd_approx32))
print(paste0(" Approx. CD of H vs G: ",cd_approx33))
```

* Using the trapezoidal Riemann sum-based approximation:

```{r}
# apply approximation for each
cd_approx41 <- approx_cd_uneq(q_F = q_F_temp, tau_F = p_temp,
                             q_G = q_G_temp, tau_G = p_temp,
                             approx_rule="trapezoid") # approximation
cd_approx42 <- approx_cd_uneq(q_F = q_F_temp,tau_F = p_temp,
                          q_G = q_H_temp, tau_G = p_temp,
                          approx_rule="trapezoid") # approximation
cd_approx43 <- approx_cd_uneq(q_F = q_H_temp,  tau_F = p_temp,
                          q_G = q_G_temp, tau_G = p_temp,
                          approx_rule="trapezoid") # approximation

print(paste0("Approx. CD of F vs G: ",cd_approx41))
print(paste0("Approx. CD of F vs H: ",cd_approx42))
print(paste0(" Approx. CD of H vs G: ",cd_approx43))
```

