---
title: "Forecasting Model Similarity (for inc hosp)"
author: "Johannes Bracher, Evan Ray, Nick Reich, Nutcha Wattanachit, Li Shandross"
date: "06/10/2021"
header-includes:
   - \usepackage{tabularx}
   - \usepackage{hyperref}
   - \usepackage{wrapfig}
   - \usepackage{float}
   - \usepackage{colortbl}
   - \usepackage{pdflscape}
   - \usepackage{tabu}
   - \usepackage{xcolor}
output:
  pdf_document:
        latex_engine: xelatex
---

```{r setup, include=FALSE}
library(tidyverse)
library(energy)
library(knitr)
library(data.table)
library(covidHubUtils)
#devtools::install_github("reichlab/covidHubUtils")
library(lubridate)
library(zoltr)
library(igraph)
library(gtools)
library(gridExtra)
knitr::opts_chunk$set(echo=FALSE,
                       comment = FALSE, message=FALSE, fig.show= 'hold',fig.pos="H",table.placement='H',
                       fig.align = 'center')
```


# COVID-19 Forecasting Model Similarity Analysis for 1-4 Week Ahead Incident Hospitalization 

## 5 locations with the highest number of COVID-19 hospitalizations by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the highest number of COVID-19 hospitalizations by end of May 2021, all probability levels, from the target end date of December, 17th 2020 to June 10th, 2021 .

```{r}
# rewrite frame_format() to work w/ hosp data
frame_format2 <- function(zoltr_frame){
  n_locs <- length(unique(zoltr_frame$location))
  # filter
  formatted_frame <- zoltr_frame %>%
    dplyr::filter(!any(is.na(value)),
                  !any(is.null(value))) %>%
    # filtering on quantile, which is the smallest
    dplyr::group_by(location, horizon_week, target_end_date, model) %>%
    mutate(n_q = n_distinct(quantile)) %>%
    ungroup() %>%
    dplyr::filter(n_q==max(n_q)) %>%
    dplyr::select(-"n_q") %>%
    # start filtering date and location and horizon
    group_by(model, horizon_week,  target_end_date) %>% #Add count of locations
    mutate(n_locations = n_distinct(location)) %>%
    dplyr::filter(n_locations==n_locs) %>%
    ungroup()  %>%
    group_by(model, location, target_end_date) %>% #Add count of weeks
    dplyr::mutate(n_horizons = n_distinct(horizon_week)) %>%
    ungroup() %>%
    dplyr::filter(n_horizons==max(n_horizons)) %>%
    group_by(model, horizon_week, location) %>%
    mutate(n_dates = n_distinct(target_end_date)) %>%
    ungroup() %>%
    dplyr::filter(n_dates==max(n_dates)) %>%
    dplyr::select(-c("n_horizons","n_locations","n_dates"))
  # final clean-up
  matrix_frame <- formatted_frame %>%
    dplyr::select("location","target_variable","target_end_date",
                  "type","quantile","model","value","horizon_week") %>%
    rename(horizon = `horizon_week`) %>% 
    dplyr::arrange(location,horizon,target_variable,target_end_date,model,quantile) %>%
    tidyr::pivot_wider(names_from = model, values_from = value) %>%
    dplyr::select_if(~ !any(is.na(.)))
  return(matrix_frame)
} 
```

```{r}
source("./functions/distance_func_script.R")
# set targets for analysis
target_horizon <- 1:4
target_var <- "inc hosp"
# each target will have different sets of models based on the current filtering
## high count
wide_frame_hosp_high <- read.csv("./data/quantile_frame_hosp_top.csv")

h_frame_high <- wide_frame_hosp_high %>% 
  frame_format2()
```

```{r}
scatter2 <- function(data,title_name,metadata=NULL){
  if (is.null(metadata)) {
    dat <- data %>% 
      dplyr::mutate(Model=model_2) 
    
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model)) + 
      geom_point(alpha=0.6,size=0.8) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  } else {
    dat <- data %>% 
      dplyr::left_join(metadata,by=c("model_2"="model_abbr")) %>%
      dplyr::mutate(Model=model_2) 
    
    dat$model_type <- ifelse(dat$ensemble, 
                             "ensemble", 
                             ifelse(dat$hybrid,
                                    "hybrid",
                                    ifelse(dat$stats,
                                           "statistical",
                                           ifelse(dat$agent_based,
                                                  "agent-based",
                                                  ifelse(dat$compartmental,
                                                         "compartmental",
                                                         "machine learning")))))
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model,group=model_type)) + 
      geom_point(alpha=0.6,size=0.8,aes(shape=model_type)) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  }
}

```



```{r}
# hosp forecast
loc_name_high <-  unique(wide_frame_hosp_high[,c("abbreviation","location")])
# calculate distance matrices
q_set_high <- unique(h_frame_high$quantile) 
approx_cd_list_high <- build_distance_frame(h_frame_high, 
                           horizon_list=c(1:4),
                           target_list="inc hosp",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set_high,tau_G=q_set_high)

  
# extract data
total_frame_high <- approx_cd_list_high[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame_high$target_end_date <- as.Date(total_frame_high$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name_high$location){
  tmp <- approx_cd_list_high[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("h_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name_high$location){
    tmp <- approx_cd_list_high[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name_high$abbreviation[which(loc_name_high$location==loc)],
                                "- Mean Approx. CD - Inc Hosp Forecasts by Horizon")))
      tmp <-total_frame_high %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter2(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name_high$abbreviation[which(loc_name_high$location==loc)]) )
    )
}
```


We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,out.width="95%", fig.align='center'}
# print heatmapes
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,out.width="95%", fig.align='center'}
# print scatterplots
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r,out.width="95%", fig.align='center', message=FALSE, warning=FALSE}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("h_frame_loc",loc_name_high$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc hosp - ",loc_name_high$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```

## 5 locations with the lowest number of COVID-19 deaths by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the lowest number of COVID-19 deaths by the end of February 2021, all probability levels, from the target end date of December, 17th 2020 to June 10th, 2021 .


```{r}
# low count
wide_frame_hosp_low <- read.csv("./data/quantile_frame_hosp_bottom.csv")

h_frame_low <- wide_frame_hosp_low %>% 
  frame_format2()


loc_name_low <-  unique(wide_frame_hosp_low[,c("abbreviation","location")])
# calculate distance matrices
q_set_low <- unique(h_frame_low$quantile) 
approx_cd_list_low <- build_distance_frame(h_frame_low, 
                           horizon_list=c(1:4),
                           target_list="inc hosp",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set_low,tau_G=q_set_low)

# extract data
total_frame_low <- approx_cd_list_low[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame_low$target_end_date <- as.Date(total_frame_low$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name_low$location){
  tmp <- approx_cd_list_low[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("h_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name_low$location){
    tmp <- approx_cd_list_low[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name_low$abbreviation[which(loc_name_low$location==loc)],
                                "- Mean Approx. CD - Inc Hosp Forecasts by Horizon")))
      tmp <-total_frame_low %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter2(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name_low$abbreviation[which(loc_name_low$location==loc)]) )
    )
}
```

We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,out.width="95%", fig.align='center'}
# print heatmapes
for(loc in loc_name_low$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,out.width="95%", fig.align='center'}
# print scatterplots
for(loc in loc_name_low$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r,out.width="95%", fig.align='center'}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("h_frame_loc",loc_name_low$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc hosp - ",loc_name_low$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```