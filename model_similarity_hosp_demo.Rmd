---
title: "Forecasting Model Similarity (for inc hosp)"
author: "Johannes Bracher, Evan Ray, Nick Reich, Nutcha Wattanachit, Li Shandross"
date: "06/23/2021"
header-includes:
   - \usepackage{tabularx}
   - \usepackage{hyperref}
   - \usepackage{wrapfig}
   - \usepackage{float}
   - \usepackage{colortbl}
   - \usepackage{pdflscape}
   - \usepackage{tabu}
   - \usepackage{xcolor}
output:
  pdf_document:
        latex_engine: xelatex
---

```{r setup, include=FALSE}
library(tidyverse)
library(energy)
library(knitr)
library(data.table)
library(covidHubUtils)
#devtools::install_github("reichlab/covidHubUtils")
library(lubridate)
library(zoltr)
library(igraph)
library(gtools)
library(gridExtra)
knitr::opts_chunk$set(echo=FALSE,
                       comment = FALSE, message=FALSE, fig.show= 'hold',fig.pos="H",table.placement='H',
                       fig.align = 'center')
```


# COVID-19 Forecasting Model Similarity Analysis for 1-4 Week Ahead Incident Hospitalization 




## 5 locations with the highest number of COVID-19 hospitalizations by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the highest number of COVID-19 hospitalizations by end of May 2021, all probability levels, from the target end date of December, 17th 2020 to June 10th, 2021 .

```{r}
# rewrite frame_format() to work w/ hosp data
frame_format2 <- function(zoltr_frame){
  n_locs <- length(unique(zoltr_frame$location))
  # filter
  formatted_frame <- zoltr_frame %>%
    dplyr::filter(!any(is.na(value)),
                  !any(is.null(value))) %>%
    # filtering on quantile, which is the smallest
    dplyr::group_by(location, horizon_week, target_end_date, model) %>%
    mutate(n_q = n_distinct(quantile)) %>%
    ungroup() %>%
    dplyr::filter(n_q==max(n_q)) %>%
    dplyr::select(-"n_q") %>%
    # start filtering date and location and horizon
    group_by(model, horizon_week,  target_end_date) %>% #Add count of locations
    mutate(n_locations = n_distinct(location)) %>%
    dplyr::filter(n_locations==n_locs) %>%
    ungroup()  %>%
    group_by(model, location, target_end_date) %>% #Add count of weeks
    dplyr::mutate(n_horizons = n_distinct(horizon_week)) %>%
    ungroup() %>%
    dplyr::filter(n_horizons==max(n_horizons)) %>%
    group_by(model, horizon_week, location) %>%
    mutate(n_dates = n_distinct(target_end_date)) %>%
    ungroup() %>%
    dplyr::filter(n_dates==max(n_dates)) %>%
    dplyr::select(-c("n_horizons","n_locations","n_dates"))
  # final clean-up
  matrix_frame <- formatted_frame %>%
    dplyr::select("location","target_variable","target_end_date",
                  "type","quantile","model","value","horizon_week") %>%
    rename(horizon = `horizon_week`) %>% 
    dplyr::arrange(location,horizon,target_variable,target_end_date,model,quantile) %>%
    tidyr::pivot_wider(names_from = model, values_from = value) %>%
    dplyr::select_if(~ !any(is.na(.)))
  return(matrix_frame)
} 
```

```{r}
source("./functions/distance_func_script.R")
# set targets for analysis
target_horizon <- 1:4
target_var <- "inc hosp"
# each target will have different sets of models based on the current filtering
## high count
wide_frame_hosp_high <- read.csv("./data/quantile_frame_hosp_top.csv")

h_frame_high <- wide_frame_hosp_high %>% 
  frame_format2()

# try to select more models --------------------------------------------------------------------
first_end_date <- as.Date("2020-12-31") 
most_recent_end_date <- as.Date("2021-06-10") # pick a date

date_range <- seq.Date(from = first_end_date, to = most_recent_end_date, by = "week")
date_range <- as.Date(date_range)

test <- map_dfr(date_range,
                 function(x) {
                   covidHubUtils::load_latest_forecasts(last_forecast_date = x,
                                                        forecast_date_window_size=6,
                                                        # pick one
                                                        locations = hlocs_high,
                                                        types = "quantile",
                                                        targets = target_list,
                                                        source = "zoltar")
                   })

#create new col to make division of forecasts - by "week" (7 days of forecasts grouped together)
test <- test %>%
  dplyr::filter(weekdays(`target_end_date`) == weekdays(most_recent_end_date)) %>%
  dplyr::mutate(horizon_week = case_when(
    horizon %in% 1:7 ~ 1,
    horizon %in% 8:14 ~ 2, 
    horizon %in% 15:21 ~ 3,
    horizon %in% 21:28 ~ 4,
  ))


test <- test %>%
 # filter(forecast_date > as.Date("2020-12-24")) %>%
  frame_format2()

unique(select(filter(arrange(test, horizon), target_end_date==as.Date("2020-12-31")), horizon))  
```

```{r}
scatter2 <- function(data,title_name,metadata=NULL){
  if (is.null(metadata)) {
    dat <- data %>% 
      dplyr::mutate(Model=model_2) 
    
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model)) + 
      geom_point(alpha=0.6,size=0.8) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  } else {
    dat <- data %>% 
      dplyr::left_join(metadata,by=c("model_2"="model_abbr")) %>%
      dplyr::mutate(Model=model_2) 
    
    dat$model_type <- ifelse(dat$ensemble, 
                             "ensemble", 
                             ifelse(dat$hybrid,
                                    "hybrid",
                                    ifelse(dat$stats,
                                           "statistical",
                                           ifelse(dat$agent_based,
                                                  "agent-based",
                                                  ifelse(dat$compartmental,
                                                         "compartmental",
                                                         "machine learning")))))
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model,group=model_type)) + 
      geom_point(alpha=0.6,size=0.8,aes(shape=model_type)) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  }
}

```



```{r}
# hosp forecast
loc_name_high <-  unique(wide_frame_hosp_high[,c("abbreviation","location")])
# calculate distance matrices
q_set_high <- unique(h_frame_high$quantile) 
approx_cd_list_high <- build_distance_frame(h_frame_high, 
                           horizon_list=c(1:4),
                           target_list="inc hosp",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set_high,tau_G=q_set_high)

  
# extract data
total_frame_high <- approx_cd_list_high[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame_high$target_end_date <- as.Date(total_frame_high$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name_high$location){
  tmp <- approx_cd_list_high[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("h_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name_high$location){
    tmp <- approx_cd_list_high[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name_high$abbreviation[which(loc_name_high$location==loc)],
                                "- Mean Approx. CD - Inc Hosp Forecasts by Horizon")))
      tmp <-total_frame_high %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter2(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name_high$abbreviation[which(loc_name_high$location==loc)]) )
    )
}
```


We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,out.width="95%", fig.align='center'}
# print heatmapes
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

It appears that the Covid19Sim-Simulator is the least similar to the other models, across all five high count locations and horizons. It is the least similar in California and Texas and less dissimilar in the other three locations, Florida, Georgia, and New York. In Texas, JHUAPL-Bucky seems to show some difference from other models but not to the extend of the Covid19Sim-Simulator. 


We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,out.width="95%", fig.align='center'}
# print scatterplots
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

The scatterplots show that the Covid19Sim-Simulator and JHUAPL-Bucky models tend to have higher approximate Cramer's Distance from the Covidhub-ensemble model compared to the other three models. This seems to align with the results shown in the heat maps above that show that Covid19Sim-Simulator and JHUAPL-Bucky tend to have the highest mean Cramer's Distance from the other models. 


We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r,out.width="95%", fig.align='center', message=FALSE, warning=FALSE}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("h_frame_loc",loc_name_high$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc hosp - ",loc_name_high$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```

Except for the 4 week ahead inc hosp dendrogram for California, all of the dendrograms show that Covid19Sim-Simulator and JHUAPL-Bucky are the least similar to the other models, splitting away in the first or second groupings, respectively.


## 5 locations with the lowest number of COVID-19 deaths by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the lowest number of COVID-19 deaths by the end of February 2021, all probability levels, from the target end date of December, 17th 2020 to June 10th, 2021 .


```{r}
# low count
wide_frame_hosp_low <- read.csv("./data/quantile_frame_hosp_bottom.csv")

h_frame_low <- wide_frame_hosp_low %>% 
  frame_format2()


loc_name_low <-  unique(wide_frame_hosp_low[,c("abbreviation","location")])
# calculate distance matrices
q_set_low <- unique(h_frame_low$quantile) 
approx_cd_list_low <- build_distance_frame(h_frame_low, 
                           horizon_list=c(1:4),
                           target_list="inc hosp",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set_low,tau_G=q_set_low)

# extract data
total_frame_low <- approx_cd_list_low[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame_low$target_end_date <- as.Date(total_frame_low$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name_low$location){
  tmp <- approx_cd_list_low[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("h_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name_low$location){
    tmp <- approx_cd_list_low[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name_low$abbreviation[which(loc_name_low$location==loc)],
                                "- Mean Approx. CD - Inc Hosp Forecasts by Horizon")))
      tmp <-total_frame_low %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter2(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name_low$abbreviation[which(loc_name_low$location==loc)]) )
    )
}
```

We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,out.width="95%", fig.align='center'}
# print heatmapes
for(loc in loc_name_low$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

For the five low count locations, Covid19Sim-Simulator is likewise the most dissimilar from the other models with the largest calculator Cramer's distance over most locations and horizons. However, JHUAPL-Bucky is also fairly dissimilar from other models at horizons of three or four weeks, surpassing the Covid19Sim-Simulator in Cramer's Distance from other models in Hawaii and Vermont for the two larger horizons. 

We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,out.width="95%", fig.align='center'}
# print scatterplots
for(loc in loc_name_low$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

Like for the high count locations, Covid19Sim-Simulator and JHUAPL-Bucky are shown to generally have the highest Cramer's Distance from the Covidhub-ensemble model. However, we note that in Arkansas only Covid19Sim-Simulator has a noticeably larger Cramer's Distance while in North Dakota only JHUAPL-Bucky has a noticeably larger Cramer's Distance. 

We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r,out.width="95%", fig.align='center'}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("h_frame_loc",loc_name_low$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc hosp - ",loc_name_low$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```

Covid19Sim-Simulator and JHUAPL-Bucky are the least similar according to the dendrograms for the five low locations, except for 4 wk ahead in Arkansas and 4 wk ahead in Vermont, which is similar to the results shown for the high count locations.     