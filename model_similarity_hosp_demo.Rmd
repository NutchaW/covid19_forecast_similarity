---
title: "Forecasting Model Similarity (for inc hosp)"
author: "Johannes Bracher, Evan Ray, Nick Reich, Nutcha Wattanachit, Li Shandross"
date: "06/10/2021"
header-includes:
   - \usepackage{tabularx}
   - \usepackage{hyperref}
   - \usepackage{wrapfig}
   - \usepackage{float}
   - \usepackage{colortbl}
   - \usepackage{pdflscape}
   - \usepackage{tabu}
   - \usepackage{xcolor}
output:
  pdf_document:
        latex_engine: xelatex
---

```{r setup, include=FALSE}
library(tidyverse)
library(energy)
library(knitr)
library(data.table)
library(covidHubUtils)
#devtools::install_github("reichlab/covidHubUtils")
library(lubridate)
library(zoltr)
library(igraph)
library(gtools)
library(gridExtra)
knitr::opts_chunk$set(echo=FALSE,
                       comment = FALSE, message=FALSE, fig.show= 'hold',fig.pos="H",table.placement='H',
                       fig.align = 'center')
```


# COVID-19 Forecasting Model Similarity Analysis for 1-4 Week Ahead Incident Hospitalization 

## 5 locations with the highest number of COVID-19 hospitalizations by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the highest number of COVID-19 hospitalizations by end of May 2021, all probability levels, from the target end date of December, 17th 2020 to June 10th, 2021 .

```{r}
# rewrite frame_format() to work w/ hosp data
frame_format2 <- function(zoltr_frame){
  n_locs <- length(unique(zoltr_frame$location))
  # filter
  formatted_frame <- zoltr_frame %>%
    dplyr::filter(!any(is.na(value)),
                  !any(is.null(value))) %>%
    # filtering on quantile, which is the smallest
    dplyr::group_by(location, horizon_week, target_end_date, model) %>%
    mutate(n_q = n_distinct(quantile)) %>%
    ungroup() %>%
    dplyr::filter(n_q==max(n_q)) %>%
    dplyr::select(-"n_q") %>%
    # start filtering date and location and horizon
    group_by(model, horizon_week,  target_end_date) %>% #Add count of locations
    mutate(n_locations = n_distinct(location)) %>%
    dplyr::filter(n_locations==n_locs) %>%
    ungroup()  %>%
    group_by(model, location, target_end_date) %>% #Add count of weeks
    dplyr::mutate(n_horizons = n_distinct(horizon_week)) %>%
    ungroup() %>%
    dplyr::filter(n_horizons==max(n_horizons)) %>%
    group_by(model, horizon_week, location) %>%
    mutate(n_dates = n_distinct(target_end_date)) %>%
    ungroup() %>%
    dplyr::filter(n_dates==max(n_dates)) %>%
    dplyr::select(-c("n_horizons","n_locations","n_dates"))
  # final clean-up
  matrix_frame <- formatted_frame %>%
    dplyr::select("location","target_variable","target_end_date",
                  "type","quantile","model","value","horizon_week") %>%
    rename(horizon = `horizon_week`) %>% 
    dplyr::arrange(location,horizon,target_variable,target_end_date,model,quantile) %>%
    tidyr::pivot_wider(names_from = model, values_from = value) %>%
    dplyr::select_if(~ !any(is.na(.)))
  return(matrix_frame)
} 
```

```{r}
source("./functions/distance_func_script.R")
# set targets for analysis
target_horizon <- 1:4
target_var <- "inc hosp"
# each target will have different sets of models based on the current filtering
## high count
wide_frame_hosp <- read.csv("./data/quantile_frame_hosp_top.csv")

h_frame_high <- wide_frame_hosp %>% 
  frame_format2()

#############
library(ggplot2)
base_data <- filter(wide_frame_hosp, location == "6", quantile == 0.05, horizon_week == 1)
ggplot(base_data, aes(x = target_end_date, y = value, color = model)) + geom_point() + geom_line()
```

```{r}
scatter2 <- function(data,title_name,metadata=NULL){
  if (is.null(metadata)) {
    dat <- data %>% 
      dplyr::mutate(Model=model_2) 
    
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model)) + 
      geom_point(alpha=0.6,size=0.8) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  } else {
    dat <- data %>% 
      dplyr::left_join(metadata,by=c("model_2"="model_abbr")) %>%
      dplyr::mutate(Model=model_2) 
    
    dat$model_type <- ifelse(dat$ensemble, 
                             "ensemble", 
                             ifelse(dat$hybrid,
                                    "hybrid",
                                    ifelse(dat$stats,
                                           "statistical",
                                           ifelse(dat$agent_based,
                                                  "agent-based",
                                                  ifelse(dat$compartmental,
                                                         "compartmental",
                                                         "machine learning")))))
    ggplot(dat, aes(x=target_end_date, y=approx_cd,col=Model,group=model_type)) + 
      geom_point(alpha=0.6,size=0.8,aes(shape=model_type)) + 
      geom_line(alpha=0.4) +
      ggtitle(title_name) +
      ylab("Approx. CD") +
      xlab("Forecast End Date") +
      facet_wrap(vars(horizon), nrow = 2,scales = "free") +
      theme(legend.text = element_text(size=5),
            legend.title = element_text(size=7),
            axis.text.x=element_text(size=rel(0.7),angle=45,hjust=1),
            legend.key.size = unit(0.5, 'cm'))+
      scale_x_date(date_breaks = "1 month",
                   date_labels = "%m-%y")
  }
}

```



```{r}
# hosp forecast
loc_name_high <-  unique(wide_frame_hosp[,c("abbreviation","location")])
# calculate distance matrices
q_set_high <- unique(h_frame_high$quantile) 
approx_cd_list_high <- build_distance_frame(h_frame_high, 
                           horizon_list=c(1:4),
                           target_list="inc hosp",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set_high,tau_G=q_set_high)

  
# extract data
total_frame <- approx_cd_list_high[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame$target_end_date <- as.Date(total_frame$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name_high$location){
  tmp <- approx_cd_list_high[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("d_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name_high$location){
    tmp <- approx_cd_list_high[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name_high$abbreviation[which(loc_name_high$location==loc)],
                                "- Mean Approx. CD - Inc Hosp Forecasts by Horizon")))
      tmp <-total_frame %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter2(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name_high$abbreviation[which(loc_name_high$location==loc)]) )
    )
}
```

We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,fig.align='center'}
# print heatmapes
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,fig.align='center'}
# print scatterplots
for(loc in loc_name_high$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("d_frame_loc",loc_name_high$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc hosp - ",loc_name_high$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```

## 5 locations with the lowest number of COVID-19 deaths by the end of February 2021

The pairwise approximated Cramer's distances are calculated for the models that have complete submissions for all target, all 5 locations with the lowest number of COVID-19 deaths by the end of February 2021, all probability levels, from the target end date of October, 17th 2020 to May 29th, 2021 .

```{r}
# death forecast
loc_name <-  unique(wide_frame_death_low[,c("abbreviation","location")])
# calculate distance matrices
q_set <- unique(d_frame_low$quantile) 
approx_cd_list <- build_distance_frame(d_frame_low, 
                           horizon_list=c(1:4),
                           target_list="inc death",
                           approx_rule="trapezoid_riemann",
                           tau_F=q_set,tau_G=q_set)

# extract data
total_frame <- approx_cd_list[[1]] %>%
  dplyr::mutate(pair=paste(model_1,model_2,sep=" vs "))
total_frame$target_end_date <- as.Date(total_frame$target_end_date,origin="1970-01-01")

# build some data frame
for(loc in loc_name$location){
  tmp <- approx_cd_list[[2]] %>% 
    dplyr::filter(location==loc) 
  tmp_list <-  lapply(1:4, function(x) cd_matrix(tmp,x))
  assign(paste0("d_frame_loc",loc), tmp_list)
}

# build heatmaps and scatter plots
for(loc in loc_name$location){
    tmp <- approx_cd_list[[2]] %>%
    dplyr::filter(location==loc)
    assign(paste0("p_",loc),
      distance_heatmap(tmp,
                       paste0(loc_name$abbreviation[which(loc_name$location==loc)],
                                "- Mean Approx. CD - Inc Death Forecasts by Horizon")))
      tmp <-total_frame %>%
          dplyr::filter(location==loc) %>%
          dplyr::group_by(horizon,target_end_date) %>%
          dplyr::filter(model_1 =="COVIDhub-ensemble",
                        model_2 != "COVIDhub-ensemble") %>%
          dplyr:: ungroup()
      assign(paste0("t_",loc),
             scatter(tmp,
            paste0("Approx. CD from COVIDhub-ensemble Over Time  - ",
                loc_name$abbreviation[which(loc_name$location==loc)]) )
    )
}
```

We can visualize the mean approximated pairwise distances across all time points in a heat map shown below. The distance from the model to itself is zero. The $x-$axis is arranged based in an ascending order of the model's approximate pairwise distance from the COVIDhub-ensemble. So, the first model is the model that is most dissimilar (on average) to the ensemble in this time frame.

```{r,fig.align='center'}
# print heatmapes
for(loc in loc_name$location){
  print(do.call(get,list(paste0("p_",loc))))
}
```

We can also look at the approximated pairwise distances to see how the models become more similar or dissimilar over time.

```{r,fig.align='center'}
# print scatterplots
for(loc in loc_name$location){
  print(do.call(get,list(paste0("t_",loc))))
}
```

We can cluster the distances using hierarchical clustering. Different linkages will result in different clusters, we probably should investigate more later. 

```{r}
library(ggdendro)
for(j in 1:5){
for(i in 1:4){
    assign(paste0("dp_",i),
    ggdendrogram(
      hclust(as.dist(get(paste0("d_frame_loc",loc_name$location[j]))[[i]]), method = "ward.D", members = NULL)
      ,size = 2) +
      labs(title=paste0("Dendrogram - ",i, " wk ahead inc death - ",loc_name$abbreviation[j]))+
      xlab("") +
      ylab("Mean Cramer's Distance") +
      theme(axis.text.x = element_text(size=5),
            axis.text.y = element_text(size=7),
            plot.margin=unit(c(0,0,0,0),"cm"),
            plot.title = element_text(size=8)))
  } 
  grid.arrange(dp_1,dp_2,dp_3,dp_4,nrow=2)
}
```